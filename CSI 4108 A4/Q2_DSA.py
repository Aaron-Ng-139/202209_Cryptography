import hashlib
from Crypto.PublicKey import DSA

# # Used to generate key pair
# DSAkey=DSA.generate(int(1024))
# p=DSAkey.p; q=DSAkey.q; g= DSAkey.domain()[2]
# print(p)
# print(q)
# print(g)

# Generated from above
p = 166908634083704717798145075854598693430795653976206881916532608828523245603439447777998474622599284545048494242560507804735102709409703986040362817312076799114353981577032167701504568063038803431419114613244733449563523013267380463112265270185943953921441151075531877582602031507474581172785524192660063507483
q = 1429259239409870121351108700674303082924063653307
g = 164469706507664305012434282200621548271114912901268903258944708861891466838461582678631546121559698919927608206764121875848449875053917512129605472603418503968566860756289931662231944879982717529049771054336680014135498486973669545386421465365701305091524239826786519043109800326844313662648146264196146805022

x = 9325
y = pow(g, x, p)

m = b'522346828557612'

# Signing message
k = 2098
k_inv = pow(k, -1, q)
r = pow(pow(g, k, p), 1, q)
s = pow( (int(hashlib.sha1(m).hexdigest(), 16) + x*r) * k_inv , 1, q)
signature = [r,s]

# Verifying message
s_inv = pow(s, -1, q)
u_1 = pow( (int(hashlib.sha1(m).hexdigest(), 16) * s_inv) , 1, q)
u_2 = pow( (r * s_inv), 1, q)
if ( pow( pow( (g^u_1 * y*u_2) , 1, p), 1, q ) ) :
    print("valid")
else:
    print("invalid")
